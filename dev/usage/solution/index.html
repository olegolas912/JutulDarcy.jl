<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solving the equations · JutulDarcy.jl</title><meta name="title" content="Solving the equations · JutulDarcy.jl"/><meta property="og:title" content="Solving the equations · JutulDarcy.jl"/><meta property="twitter:title" content="Solving the equations · JutulDarcy.jl"/><meta name="description" content="Documentation for JutulDarcy.jl."/><meta property="og:description" content="Documentation for JutulDarcy.jl."/><meta property="twitter:description" content="Documentation for JutulDarcy.jl."/><meta property="og:url" content="https://sintefmath.github.io/JutulDarcy.jl/usage/solution/"/><meta property="twitter:url" content="https://sintefmath.github.io/JutulDarcy.jl/usage/solution/"/><link rel="canonical" href="https://sintefmath.github.io/JutulDarcy.jl/usage/solution/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JutulDarcy.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JutulDarcy.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/intro/">Getting started</a></li><li><a class="tocitem" href="../../examples/two_phase_gravity_segregation/">Gravity segregation</a></li><li><a class="tocitem" href="../../examples/two_phase_buckley_leverett/">Two-phase Buckley-Leverett</a></li><li><a class="tocitem" href="../../examples/two_phase_unstable_gravity/">Gravity circulation with CPR preconditioner</a></li><li><a class="tocitem" href="../../examples/wells_intro/">Intro to wells</a></li><li><a class="tocitem" href="../../examples/five_spot_ensemble/">Quarter-five-spot with variation</a></li><li><a class="tocitem" href="../../examples/co2_brine_2d_vertical/">Intro to compositional flow</a></li><li><a class="tocitem" href="../../examples/compositional_5components/">Compositional with five components</a></li><li><a class="tocitem" href="../../examples/optimize_simple_bl/">Parameter optimization of Buckley-Leverett</a></li><li><a class="tocitem" href="../../examples/mrst_validation/">Validation of reservoir simulator</a></li></ul></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../systems/">Supported physical systems</a></li><li class="is-active"><a class="tocitem" href>Solving the equations</a><ul class="internal"><li><a class="tocitem" href="#Newton&#39;s-method"><span>Newton&#39;s method</span></a></li><li><a class="tocitem" href="#Linear-solvers-and-linear-systems"><span>Linear solvers and linear systems</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li><li class="toplevel"><a class="tocitem" href="#Parallel-simulations"><span>Parallel simulations</span></a></li><li><a class="tocitem" href="#Overview-of-parallel-support"><span>Overview of parallel support</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Usage</a></li><li class="is-active"><a href>Solving the equations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solving the equations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/sintefmath/JutulDarcy.jl/blob/main/docs/src/usage/solution.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Solving-the-equations"><a class="docs-heading-anchor" href="#Solving-the-equations">Solving the equations</a><a id="Solving-the-equations-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-equations" title="Permalink"></a></h1><p>By default, Jutul solves a system as a fully-coupled implicit system of equations discretized with a two-point flux approximation with single-point upwind.</p><h2 id="Newton&#39;s-method"><a class="docs-heading-anchor" href="#Newton&#39;s-method">Newton&#39;s method</a><a id="Newton&#39;s-method-1"></a><a class="docs-heading-anchor-permalink" href="#Newton&#39;s-method" title="Permalink"></a></h2><p>The standard way of solving a system of non-linear equations is by Newton&#39;s method (also known as Newton-Raphson&#39;s method). A quick recap: For a vector valued residual <span>$\mathbf{r}(x)$</span> of the primary variable vector <span>$\mathbf{x}$</span> we can defined a Newton update:</p><p class="math-container">\[\mathbf{x}^{k+1} = \mathbf{r}^k - J^{-1} \mathbf{r}(\mathbf{x}^k), \quad J_{ij} = \frac{\partial \mathbf{r}_i}{\partial \mathbf{x}_j}.\]</p><p>JutulDarcy solves systems that generally have both non-smooth behavior and physical constraints on the values for <span>$\textbf{x}$</span>. For that reason, we modify Newton&#39;s method slightly:</p><p class="math-container">\[\mathbf{x}^{k+1} = \mathbf{r}^k + \omega(\Delta \mathbf{x})\]</p><p>Here, <span>$\omega$</span> is a function that limits the variables so that they do not change too much (e.g. Appleyard chopping, limiting of pressure, saturation and composition updates) and that they are within the prescribed limits. There are also options for automated global dampening in the presence of convergence issues. The update is then defined from inverting the Jacobian:</p><p class="math-container">\[\Delta \mathbf{x} = -J^{-1} \mathbf{r}(\mathbf{x}^k), \quad J_{ij} = \frac{\partial \mathbf{r}_i}{\partial \mathbf{x}_j}.\]</p><p>Starting with <span>$\mathbf{x}^0$</span>as some initial guess taken from the previous time-step, we can solve the system by iterating upon this loop.</p><h2 id="Linear-solvers-and-linear-systems"><a class="docs-heading-anchor" href="#Linear-solvers-and-linear-systems">Linear solvers and linear systems</a><a id="Linear-solvers-and-linear-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-solvers-and-linear-systems" title="Permalink"></a></h2><p>For most practical applications it is not feasible or efficient to invert the Jacobian. JutulDarcy uses preconditioned iterative solvers by default, but it is possible to use direct solvers as well when working with smaller models. The high level interface for setting up a reservoir model <a href="../../internals/#JutulDarcy.setup_reservoir_model-Tuple{DataDomain, Any}"><code>setup_reservoir_model</code></a> has an optional <code>block_backend=true</code> keyword argument that determines the matrix format, and consequently the linear solver type to be used.</p><h3 id="Direct-solvers"><a class="docs-heading-anchor" href="#Direct-solvers">Direct solvers</a><a id="Direct-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-solvers" title="Permalink"></a></h3><p>If <code>block_backend</code> is set to <code>false</code>, Jutul will assemble into the standard Julia CSC sparse matrix with <code>Float64</code> elements and Julia&#39;s default direct solver will be used. It is also possible to use other Julia solvers on this system, but the default preconditioners assume that block backend is enabled.</p><h3 id="Iterative-solver"><a class="docs-heading-anchor" href="#Iterative-solver">Iterative solver</a><a id="Iterative-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Iterative-solver" title="Permalink"></a></h3><p>If <code>block_backend</code> is set to <code>true</code>, Jutul will by default use a constrained-pressure residual (CPR) preconditioner for BiCGStab. Jutul relies on <a href="https://github.com/JuliaSmoothOptimizers/Krylov.jl">Krylov.jl</a> for iterative solvers. The main function that selects the linear solver is <a href="../../internals/#JutulDarcy.reservoir_linsolve"><code>reservoir_linsolve</code></a> that allows for the selection of different preconditioners and linear solvers.</p><h4 id="Single-model-(only-porous-medium)"><a class="docs-heading-anchor" href="#Single-model-(only-porous-medium)">Single model (only porous medium)</a><a id="Single-model-(only-porous-medium)-1"></a><a class="docs-heading-anchor-permalink" href="#Single-model-(only-porous-medium)" title="Permalink"></a></h4><p>If the model is a single model (e.g. only a reservoir) the matrix format is a block-CSC matrix that combines Julia&#39;s builtin sparse matrix format with statically sized elements from the <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a> package. If we consider the two-phase immiscible system from <a href="../systems/#Multi-phase,-immiscible-flow">Multi-phase, immiscible flow</a> we have a pair of equations <span>$R_n, R_w$</span> together with the corresponding primary variables pressure and first saturation <span>$p, S_n$</span> defined for all <span>$N_c$</span> cells. Let us simplify the notation a bit so that the subscripts of the primary variables are <span>$p, s$</span> and define a <span>$N_c \times N_c$</span> block Jacobian linear system where the entires are given by:</p><p class="math-container">\[J_{ij} = \begin{bmatrix}
   \left(\frac{\partial r_{n}}{\partial p}\right)_{ij} &amp; \left(\frac{\partial r_{n}}{\partial s}\right)_{ij} \\
   \left(\frac{\partial r_{w}}{\partial p}\right)_{ij} &amp; \left(\frac{\partial r_{w}}{\partial s}\right)_{ij} \end{bmatrix} = \begin{bmatrix}
   J_{np} &amp; J_{ns} \\
   J_{wp} &amp; J_{ws}
\end{bmatrix}_{ij}\]</p><p>This block system has several advantages:</p><ul><li>We immediately get access to more powerful version of standard Julia preconditioners provided that all operations used are applicable for matrices and are applied in the right commutative order. For example, JutulDarcy uses the <a href="https://github.com/mcovalt/ILUZero.jl">ILUZero.jl</a> package when a CSC linear system is preconditioned with incomplete LU factorization with zero fill-in.</li><li>Sparse matrix vector products are much more efficient as less indicies need to be looked up for each element wise multiplication.</li><li>Performing local reductions over variables is much easier when they are located in a local matrix.</li></ul><h5 id="Constrained-Pressure-Residual"><a class="docs-heading-anchor" href="#Constrained-Pressure-Residual">Constrained Pressure Residual</a><a id="Constrained-Pressure-Residual-1"></a><a class="docs-heading-anchor-permalink" href="#Constrained-Pressure-Residual" title="Permalink"></a></h5><p>The CPR preconditioner <a href="../../internals/#JutulDarcy.CPRPreconditioner"><code>CPRPreconditioner</code></a> is a multi-stage physics-informed preconditioner that seeks to decouple the global pressure part of the system from the local  transport part. In the limits of incompressible flow without gravity it can be thought of as an elliptic / hyperbolic splitting.</p><p>The short version of the CPR preconditioner can be motivated by our test system:</p><p class="math-container">\[r_n = \frac{\partial}{\partial t} ((1 - S_w) \rho_n \phi) + \nabla \cdot (\rho_n \vec{v}_n) - \rho_n q_n = 0,\\
r_w = \frac{\partial}{\partial t} (S_w \rho_w \phi) + \nabla \cdot (\rho_w \vec{v}_w) - \rho_w q_w = 0.\]</p><p>For simplicity, we assume that there is no gravity, source terms, or compressibility. Each equation can then be divided by their respective densities and summed up to produce a pressure equation:</p><p class="math-container">\[r_p = \frac{\partial}{\partial t} ((1 - S_w) \phi) + \nabla \cdot \vec{v}_n + \frac{\partial}{\partial t} (S_w \phi) + \nabla \cdot  \vec{v}_w \\
= \frac{\partial}{\partial t} ((S_w - S_w) \phi) + \nabla \cdot (\vec{v}_n + \vec{v}_w) \\
= \nabla \cdot (\vec{v}_n + \vec{v}_w) \\
= - \nabla \mathbf{K}(k_{rw}/\mu_w + k_{rn}/\mu_n) \nabla p \\
= - \nabla \mathbf{K}\lambda_t \nabla p = 0\]</p><p>The final equation is the variable coefficient Poisson equation and is referred to as the incompressible pressure equation for a porous  media. We know that algebraic multigrid preconditioners (AMG) are highly efficient for linear systems made by discretizing this equation. The idea in CPR is to exploit this by constructing an approximate pressure equation that is suited for AMG inside the preconditioner.</p><p>Constructing the preconditioner is done in two stages:</p><ol><li>First, weights for each equation is found locally in each cell that decouples the time derivative from the non-pressure variables. In the above example, this was the true IMPES weights (dividing by density). JutulDarcy supports analytical true IMPES weights for some systems, numerical true IMPES weights for all systems and quasi IMPES weights for all systems.</li><li>A pressure equation is formed by weighting each equation by the respective weights and summing. We then have two systems: The pressure system <span>$r_p$</span> with scalar entries and the full system <span>$r$</span> that has block structure.</li></ol><p>During the linear solve, the preconditioner is then made up of two broad stages: First, a preconditioner is applied to the pressure part (typically AMG), then the full system is preconditioned (typically ILU(0)) after the residual has been corrected by the pressure estimate:</p><ol><li>Form weighted pressure residual <span>$r_p = \sum_i w_i r_i$</span>.</li><li>Apply pressure preconditioer <span>$M_p$</span>: <span>$\Delta p = M_p^{-1} r_p$</span>.</li><li>Correct global residual <span>$r^* = r - J P(\Delta p)$</span> where <span>$P$</span> expands the pressure update to the full system vector, with zero entries outside the pressure indices.</li><li>Precondition the full system <span>$\Delta x^* = M^{-1}r^*$</span></li><li>Correct the global update with the pressure to obtain the final update: <span>$\Delta x = \Delta x^* + P(\Delta p)$</span></li></ol><h4 id="Multi-model-(porous-medium-with-wells)"><a class="docs-heading-anchor" href="#Multi-model-(porous-medium-with-wells)">Multi model (porous medium with wells)</a><a id="Multi-model-(porous-medium-with-wells)-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-model-(porous-medium-with-wells)" title="Permalink"></a></h4><p>If a model is a porous medium with wells, the same preconditioners can be used, but an additional step is required to incorporate the well system. In practical terms, this means that our linearized system is expanded to multiple linear systems:</p><p class="math-container">\[J \Delta \mathbf{x} = \begin{bmatrix}
   J_{rr} &amp; J_{rw} \\
   J_{wr} &amp; J_{ww}
\end{bmatrix}
\begin{bmatrix}
\Delta \mathbf{x}_r \\
\Delta \mathbf{x}_w
\end{bmatrix}
 = 
\begin{bmatrix}
\mathbf{r}_r \\
\mathbf{r}_w
\end{bmatrix}\]</p><p>Here, <span>$J_{rr}$</span> is the reservoir equations differentiated with respect to the reservoir primary variables, i.e. the Jacobian from the previous section. <span>$J_{ww}$</span> is the well system differentiated with respect to the well primary variables. The cross terms, <span>$J_{rw}$</span>and <span>$J_{wr}$</span>, are the same equations differentiated with respect to the primary variables of the other system.</p><p>The well system is generally much smaller than the reservoir system and can be solved by a direct solver. We would like to reuse the block preconditioners defined for the base system. The approach we use is a <a href="https://en.wikipedia.org/wiki/Schur_complement">Schur complement</a> approach to solve the full system. If we linearly eliminate the dependence of the reservoir equations on the well primary variables, we obtain the reduced system:</p><p class="math-container">\[J \Delta \mathbf{x} = \begin{bmatrix}
   J_{rr} - J_{rw}J_{ww}^{-1}J_{wr} &amp; 0 \\
   J_{wr} &amp; J_{ww}
\end{bmatrix}
\begin{bmatrix}
\Delta \mathbf{x}_r \\
\Delta \mathbf{x}_w
\end{bmatrix}
 = 
\begin{bmatrix}
\mathbf{r}_r - J_{rw}J_{ww}^{-1}\mathbf{r}_w\\
\mathbf{r}_w
\end{bmatrix}\]</p><p>We can then solve the system in terms of the reservoir degrees of freedom where the system is a block linear system and we already have a working preconditioner:</p><p class="math-container">\[\left(J_{rr} - J_{rw}J_{ww}^{-1}J_{wr}\right)\mathbf{x}_r = \mathbf{r}_r - J_{rw}J_{ww}^{-1}\mathbf{r}_w\]</p><p>Once that system is solved for <span>$\mathbf{x}_r$</span>, we can recover the well degrees of freedom <span>$\mathbf{r}_w$</span> directly:</p><p class="math-container">\[\mathbf{r}_w = J_{ww}^{-1}(\mathbf{r}_w - J_{wr}\mathbf{x}_r)\]</p><div class="admonition is-info"><header class="admonition-header">Efficiency of Schur complement</header><div class="admonition-body"><p>Explicitly forming the matrix <span>$J_{rr} - J_{rw}J_{ww}^{-1}J_{wr}$</span> will generally lead to a lot of fill-in in the linear system. JutulDarcy instead uses the action of <span>$J_{rr} - J_{rw}J_{ww}^{-1}J_{wr}$</span> as a linear operator from <a href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl">LinearOperators.jl</a>. This means that we must apply the inverse of the well system every time we need to compute the residual or action of the system matrix, but fortunately performing the action of the Schur complement is inexpensive as long as <span>$J_{ww}$</span> is small and the factorization can be stored. </p></div></div><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p><a href="https://doi.org/10.2118/12265-MS">Wallis, J.R. &quot;Incomplete Gaussian Elimination as a Preconditioning for Generalized Conjugate Gradient Acceleration.&quot; Paper presented at the SPE Reservoir Simulation Symposium, San Francisco, California, November 1983</a></p><p><a href="https://doi.org/10.2118/96809-MS">Cao, H., Tchelepi, H. A., Wallis, J., and H. Yardumian. &quot;Parallel Scalable Unstructured CPR-Type Linear Solver for Reservoir Simulation.&quot; Paper presented at the SPE Annual Technical Conference and Exhibition, Dallas, Texas, October 2005</a></p><h1 id="Parallel-simulations"><a class="docs-heading-anchor" href="#Parallel-simulations">Parallel simulations</a><a id="Parallel-simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-simulations" title="Permalink"></a></h1><p>JutulDarcy can use threads by default, but advanced options can improve performance significantly for larger models.</p><h2 id="Overview-of-parallel-support"><a class="docs-heading-anchor" href="#Overview-of-parallel-support">Overview of parallel support</a><a id="Overview-of-parallel-support-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-of-parallel-support" title="Permalink"></a></h2><p>There are two main ways of exploiting multiple cores in Jutul/JutulDarcy: Threads are automatically used for assembly and can be used for parts of the linear solve. If you require the best performance, you have to go to MPI where the linear solvers can use a parallel <a href="https://hypre.readthedocs.io/en/latest/solvers-boomeramg.html">BoomerAMG preconditioner</a> via <a href="https://github.com/fredrikekre/HYPRE.jl">HYPRE.jl</a>.</p><h4 id="Shared-memory"><a class="docs-heading-anchor" href="#Shared-memory">Shared memory</a><a id="Shared-memory-1"></a><a class="docs-heading-anchor-permalink" href="#Shared-memory" title="Permalink"></a></h4><p>An experimental thread-parallel backend for matrices and linear algebra can be enabled by setting <code>backend=:csr</code> in the call to <a href="../../internals/#JutulDarcy.setup_reservoir_model-Tuple{DataDomain, Any}"><code>setup_reservoir_model</code></a>. This backend provides additional features such as a parallel zero-overlap ILU(0) implementation and parallel apply for AMG, but these features are still work in progress.</p><h4 id="MPI-support-for-distributed-memory"><a class="docs-heading-anchor" href="#MPI-support-for-distributed-memory">MPI support for distributed memory</a><a id="MPI-support-for-distributed-memory-1"></a><a class="docs-heading-anchor-permalink" href="#MPI-support-for-distributed-memory" title="Permalink"></a></h4><p>It is possible to run cases using MPI. You will have to set up an environment with the following packages under Julia 1.9+: <code>PartitionedArrays</code>, <code>MPI</code>, <code>JutulDarcy</code> and <code>HYPRE</code>. This is generally the best performing solver setup available, even if you are working in a shared memory environment.</p><p>Write your script as usual, but in your call to <code>setup_reservoir_simulator</code>, pass the optional argument <code>mode = :mpi</code>. You must then run the file using <code>mpiexec</code>. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You should be familiar with the MPI programming model to use this feature. See <a href="https://juliaparallel.org/MPI.jl/stable/">MPI.jl</a> and <a href="https://github.com/JuliaParallel/MPIClusterManagers.jl">MPIClusterManagers.jl</a> for more details, and how MPI is handled in Julia specifically.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>MPI consolidates results by writing files to disk. Unless you have a plan to work with the distributed states in-memory returned by the <code>simulate!</code> call, it is best to specify a <code>output_path</code> optional argument to <code>setup_reservoir_simulator</code>. After the simulation, that folder will contain output just as if you had run the case in serial.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../systems/">« Supported physical systems</a><a class="docs-footer-nextpage" href="../../internals/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 4 January 2024 19:08">Thursday 4 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
